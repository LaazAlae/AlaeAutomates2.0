{% extends "base.html" %}

{% set show_header = true %}

{% block header %}Processing Monthly Statements{% endblock %}

{% block content %}
<div class="upload-container">
    <div class="question-header">
        <h3>Processing Your Files</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill" style="width: 10%; animation: pulse 1.5s infinite;"></div>
        </div>
    </div>

    <div class="question-content">
        <p id="status-message">Initializing PDF processing...</p>
        <p id="elapsed-time" style="font-size: 10px; color: #666; text-align: center;"></p>
        <div style="text-align: center; margin: 10px 0;">
            <button onclick="toggleLogs()" class="btn" style="font-size: 12px; padding: 5px 10px;">Show Processing Details</button>
        </div>
    </div>

    <div id="logs-section" style="display: none; margin-top: 20px;">
        <h4>Processing Details:</h4>
        <div id="logs-container" style="background: #f5f5f5; padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; white-space: pre-wrap;"></div>
    </div>

    <div id="message-section"></div>
</div>
{% endblock %}

{% block scripts %}
<script>
let checkCount = 0;
const maxChecks = 120; // 10 minutes max (5 second intervals)
let logsVisible = false;
let lastLogCount = 0;

function toggleLogs() {
    const logsSection = document.getElementById('logs-section');
    const toggleButton = event.target;
    
    if (logsVisible) {
        logsSection.style.display = 'none';
        toggleButton.textContent = 'Show Processing Details';
        logsVisible = false;
    } else {
        logsSection.style.display = 'block';
        toggleButton.textContent = 'Hide Processing Details';
        logsVisible = true;
        fetchLogs(); // Load initial logs
    }
}

function fetchLogs() {
    if (!logsVisible) return;
    
    fetch('{{ url_for("monthly_statements.get_processing_logs", session_id=session_id) }}', {
        method: 'GET',
        headers: {
            'X-CSRFToken': document.querySelector('meta[name=csrf-token]').getAttribute('content')
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.logs && data.logs.length > lastLogCount) {
            const logsContainer = document.getElementById('logs-container');
            logsContainer.textContent = data.logs.join('\n');
            logsContainer.scrollTop = logsContainer.scrollHeight; // Auto-scroll to bottom
            lastLogCount = data.logs.length;
        }
    })
    .catch(error => {
        console.error('Failed to fetch logs:', error);
    });
}

function checkStatus() {
    checkCount++;
    
    fetch('{{ url_for("monthly_statements.get_processing_status", session_id=session_id) }}', {
        method: 'GET',
        headers: {
            'X-CSRFToken': document.querySelector('meta[name=csrf-token]').getAttribute('content')
        }
    })
    .then(response => response.json())
    .then(data => {
        const statusMessage = document.getElementById('status-message');
        const elapsedTime = document.getElementById('elapsed-time');
        const progressFill = document.getElementById('progress-fill');
        
        // Update elapsed time
        if (data.elapsed) {
            const minutes = Math.floor(data.elapsed / 60);
            const seconds = data.elapsed % 60;
            elapsedTime.textContent = `Processing time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Update status based on both processing and PDF creation
        if (data.status === 'error' || data.pdf_status === 'error') {
            statusMessage.textContent = 'An error occurred during processing.';
            showMessage('Error: ' + (data.error || 'PDF creation failed'), 'error');
            progressFill.style.animation = 'none';
            return; // Stop checking
        }
        
        // Handle completion when both processing and PDF creation are done
        if (data.status === 'completed' && data.pdf_status === 'completed') {
            statusMessage.textContent = 'Processing complete! Redirecting...';
            progressFill.style.width = '100%';
            progressFill.style.animation = 'none';
            setTimeout(() => {
                window.location.href = data.redirect_url;
            }, 1500);
            return; // Stop checking
        }
        
        // Show current step based on status
        if (data.status === 'pending') {
            statusMessage.textContent = 'Initializing PDF processing...';
            progressFill.style.width = '10%';
        } else if (data.status === 'processing') {
            statusMessage.textContent = 'Extracting statements from PDF... This may take a few minutes for large documents.';
            progressFill.style.width = '40%';
        } else if (data.status === 'completed' && data.pdf_status === 'creating') {
            statusMessage.textContent = 'Creating PDF files in background... This prevents timeouts on large files.';
            progressFill.style.width = '75%';
            // Show PDF processing time if available
            if (data.pdf_elapsed) {
                const pdfMinutes = Math.floor(data.pdf_elapsed / 60);
                const pdfSeconds = data.pdf_elapsed % 60;
                statusMessage.textContent += ` (PDF processing: ${pdfMinutes}:${pdfSeconds.toString().padStart(2, '0')})`;
            }
        } else if (data.status === 'completed') {
            statusMessage.textContent = 'Statement extraction complete. Redirecting...';
            progressFill.style.width = '60%';
        }
        
        // Fetch logs if visible
        if (logsVisible) {
            fetchLogs();
        }
        
        // Continue checking if not completed and under max checks
        if (checkCount < maxChecks) {
            setTimeout(checkStatus, 5000); // Check every 5 seconds
        } else {
            // Timeout after 10 minutes
            statusMessage.textContent = 'Processing is taking longer than expected.';
            showMessage('Processing timeout. The file may be too large for this free hosting service.', 'error');
            progressFill.style.animation = 'none';
        }
    })
    .catch(error => {
        console.error('Status check error:', error);
        showMessage('Connection error while checking status.', 'error');
    });
}

function showMessage(text, type) {
    const messageSection = document.getElementById('message-section');
    messageSection.innerHTML = `<div class="message ${type}">${text}</div>`;
}

// Start checking status
setTimeout(checkStatus, 2000); // Start after 2 seconds
</script>
{% endblock %}